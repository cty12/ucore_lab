# Lab 8 Report

计 24 陈天昱 2012011348

## Exercise 1

> 实现过程

sfs\_read() 和 sfs\_write() 都调用 sfs\_io\_nolock() ，通过 write 参数判断具体是读还是写。sfs\_io\_nolock() 作用是在内存 buffer 和磁盘之间传输内容 (content) 。

blkoff 是第一个块的偏移，如果 blkoff 不为 0 就是没有对齐，那么首先要对 offset 到第一个块结尾的内容进行读写。分别调用 sfs\_bmap\_load\_nolock() 和 sfs\_buf\_op() ，后者对 buf 进行对应的读写操作。

第二步就是对对齐的块进行读写。直到 nblks == 0 ，对每个块进行读写。

最后判断最后一个块是不是对齐的，若没有对齐，则按照第一块的方法进行操作。

> UNIX 的 PIPE 机制

定义两个函数，管道读函数 pipe\_read() 和管道写函数 pipe\_wrtie() 。管道写函数通过将字节复制到 VFS 索引节点指向的物理内存而写入数据，而管道读函数则通过复制物理内存中的字节而读出数据。内核必须利用一定的机制同步对管道的访问，为此，内核使用了锁、等待队列和信号。当写进程向管道中写入时，利用标准的库函数write()，系统根据库函数传递的文件描述符，可找到该文件的 file 结构。file 结构中指定了用来进行写操作的函数（即写入函数）地址，于是，内核调用该函数完成写操作。写入函数在向内存中写入数据之前，必须首先检查 VFS 索引节点中的信息，同时满足如下条件时，才能进行实际的内存复制工作：

- 内存中有足够的空间可容纳所有要写入的数据；
- 内存没有被读程序锁定。

如果同时满足上述条件，写入函数首先锁定内存，然后从写进程的地址空间中复制数据到内存。否则，写入进程就休眠在 VFS 索引节点的等待队列中，接下来，内核将调用调度程序，而调度程序会选择其他进程运行。写入进程实际处于可中断的等待状态，当内存中有足够的空间可以容纳写入数据，或内存被解锁时，读取进程会唤醒写入进程，这时，写入进程将接收到信号。当数据写入内存之后，内存被解锁，而所有休眠在索引节点的读取进程会被唤醒。管道的读取过程和写入过程类似。但是，进程可以在没有数据或内存被锁定时立即返回错误信息，而不是阻塞该进程，这依赖于文件或管道的打开模式。反之，进程可以休眠在索引节点的等待队列中等待写入进程写入数据。当所有的进程完成了管道操作之后，管道的索引节点被丢弃，而共享数据页也被释放。

参考资料：

[http://en.wikipedia.org/wiki/Pipeline_(Unix)](http://en.wikipedia.org/wiki/Pipeline_(Unix))  
[http://oss.org.cn/kernel-book/ch07/7.1.1.htm](http://oss.org.cn/kernel-book/ch07/7.1.1.htm)  

## Exercise 2

> 实现

在 do\_fork() 中增加 copy\_files 和相应的异常处理。

然后再修改 load\_icode() 实现从文件系统运行程序。首先调用 mm\_create() 和 setup\_pgdir() 建立页表项。然后使用 load\_icode\_read() 将 ELF 读入内存，判断 magic 是否相等，如果是说明格式正确。然后调用 mm\_map() 建立 VMA ，调用 pgdir\_alloc\_page() 分配 TEXT/DATA 段的页并将内容拷贝过来，然后再为 BSS 段分配页。使用 mm\_map() 建立用户栈。最后设置 cr3 ，切换页表，设置 trapframe 等。

> UNIX 硬链接和软链接

硬链接就是新建一个文件，它的 inode 指向链接到的文件的 inode ，另外增加一个引用计数，当引用计数为 0 的时候就删除这个文件。

软链接的实现是在 inode 里设置一个标记，然后存一个目标文件的路径。

## 小结

和参考答案基本一致。可以运行 ELF 格式的文件。
